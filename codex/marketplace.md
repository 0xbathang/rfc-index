---
title: CODEX-MARKETPLACE
name: Codex Storage Marketplace
status: raw
tags: codex
editor: Dmitriy <dryajov@status.im>
contributors:
- Mark <mark@status.im>
- Adam <adam.u@status.im>
- Eric <ericmastro@status.im>
---

## Abstract

This specification describes a method for Codex storage providers and client nodes to participate in a storage marketplace. 
The goal is to create a storage marketplace that promotes durability.

## Motivation
The Codex network aims to create a peer-to-peer storage engine with strong data durability, 
data persistence guarantees and node storage incentives.
To reach this goal, a data availability and retrieval mechanism is needed.
Support for light clients, like mobile devices should also be embraced.
The protocol should remove complexity to allow for simple implementation and 
simplify incentive mechanisms.

## Semantics 

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [2119](https://www.ietf.org/rfc/rfc2119.txt).

### Definitions

| Terminology  | Description |
| --------------- | --------- |
| storage providers | A Codex node that provides storage services to the marketplace. |
| validator nodes | A Codex node that collects, validates and submits missing storage proofs for a reward. |
| client nodes | The most common Codex node that interacts with other nodes to store, locate and retrieve data. Also considered to be an ephemeral node. |
| slots | Created by client nodes when a new dataset is requested to be stored. Discussed further in the [slots section](#slots).  |

### Storage Request

Client nodes can create storage requests on the Codex network via the Codex marketplace.
The marketplace is a smart contract deployed on a EVM-compatiable blockchain.
The smart contract MUST handle storage request, storage slot state, 
storage provider rewards, storage provider collateral, and storage proof state. 

To create a request to store a dataset on the Codex network,
client nodes MUST split the dataset into data chunks, $(c_1, c_2, c_3, \ldots, c_{n})$.
Using a erasure coding technique, 
the data chunks are encoded and placed into separate slots.
The erasure coding technique MUST be the [Reed-Soloman algorithm](https://hackmd.io/FB58eZQoTNm-dnhu0Y1XnA).

The requester, client node, SHOULD submit a transaction with the desired request parameters.
The requester MUST provide a `duration` value for the storage request along with the appropriate `reward`,
payment for request. 
Once a request is created via the transaction, 
all slots MUST be filled by storage providers before the request is officially started.
If the request does not attract enough storage providers after a pre-defined network timeout,
which is defined by the Codex node as `expiry`,
the request MUST be canceled.
If canceled, `collateral` SHOULD be returned to any storage providers and 
`reward` returned to the requester.
The requester MAY create a new request with different values to restart the process.

The storage request SHOULD initiate a new storage contract with the following parameters:

```solidity

function requestStorage() public {
  // the Codex node requesting storage
  address client;

  // content identifier
  string cid;

  // merkle root of the dataset, used to verify storage proofs
  byte32 merkleRoot;

  // tokens from the requester to reward storage providers
  uint256 reward;

  // amount of tokens required for collateral by storage providers
  UInt256 collateral;

  // frequency that proofs are checked by validator nodes
  uint256 proofProbability;

  // amount of desired time for stoage request
  uint256 duration;

  // the number of requested slots
  uint64 slots;

  // amount of storage per slot
  uint256 slotSize;

  // Amount of time before request expires
  uint256 expiry;

  // random value to differentiate from other requests
  byte32 nonce;

}

```

`cid` 

An identifier used to locate the dataset
- MUST be a sha-256 hash (length of 32 bytes), [CIDv1](https://github.com/multiformats/cid#cidv1)
- MUST be generated by the client node

`reward`

- it MUST be a token known to the network.
- it MUST be paid directly to storage providers who fill slots for the `duration` of the request

`collateral`

All storage providers MUST provide token collateral before being able to fill a storage slot.
The following is related to storage provider who has offered `collateral`

If a storage provider, filling a slot,
fails to provide enough proofs of storage, the `collateral` MUST be forfeited.
The storage provider MAY be able to fill the same failed slot,
but MUST replace any `collateral` that was already forfeited.

A portion of the `collateral` MUST be offered as a reward to validator nodes,
and a portion SHOULD be offered as a reward to other storage providers that repair empty [slots](#slots).

`proofProbability`

Storage providers are REQUIRED to provide proofs of storage that are submited to the marketplace smart contract and
verified by validator nodes.
The requester SHOULD provide the value for the frequency of proofs provided by storage providers.

`duration`

- Once the `reward` has depleted from periodic storage provider payments,
the storage request SHOULD end.
The requester MAY renew the storage request by creating a new request with the same `cid` value.
- Data MAY be considered lost during contract `duration` if storage providers fail to provide storage proofs and
no other storage providers decide to fill empty slots, see [slots](#slots) below.

### Fulfilling Requests
In order a storage request to begin,
storage providers MUST enter a storage contract with the requester via the marketplace smart contract.

When storage providers are selected to fill a slot for the request,
storage providers MUST NOT abandon the slot, unless the request is canceled or complete.
If canceled, the slot state SHOULD be changed to cancelled or failed.

#### Slots
Slots is a method used by the Codex network to distribute data chucks amongst storage providers.
Data chucks, created by clients nodes, MUST use a method of distributing the dataset for data resiliency.
- Client nodes SHOULD decide how many nodes should fill the slots of a storage contract.
- Storage providers MUST be selected to fill a slot,

Each slot represents a chunk of a dataset provided during storage request.
The first state of a slot is reserved, meaning that the slot is waiting to be reserved by a storage provider.
The Codex network selects storage providers by using a variation of the Kademila distance function, 
as described in [CODEX/NODE-DISPERSAL](https://github.com/vacp2p/rfc-index/blob/codex-disperal/codex/slot-dispersal.md).

After a slot reservation is secured, the storage provider MUST:
- provide token collateral and proof of storage to fill the slot
- provide proofs of storage periodically
Once filled, the slot state SHOULD be changed from reserved to filled.

The `reward` payout SHOULD occur periodically until the request `duration` is complete.
Once complete, the slot state SHOULD be changed to finished.

A slot MUST become empty after the storage provider fails to provide proofs of storage to validator nodes.
The state of the slot SHOULD change from filled to free.

The storage provider assigned to that slot MUST forfeit its `collateral`.
Other storage providers can earn a small portion of the forfeited `collateral` by providing a new proof of storage and `collateral`,
this is referred to as repairing the empty slot.

The slot lifecycle of a storage provider that has filled a slot is demonstrated below:

-----------

        proof &                                 proof &
      collateral   proof          missed      collateral               missed
            |        |              |               |                    |
            v        v              v               v                    v
            -------------------------------------------------------------------
     slot:  |///////////////////////|               |////////////////////|
            -------------------------------------------------------------------
                                    |                                    |
                                    v                                    v
                                Update                      Check maxNumOfSlash is reached -  Lost Collateral 
                            slashCriterion
                          (number of proofs missed)           



            ---------------- time ---------------->



## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

## References 

1. [Reed-Soloman algorithm](https://hackmd.io/FB58eZQoTNm-dnhu0Y1XnA)
2. [CIDv1](https://github.com/multiformats/cid#cidv1)
3. [Proof-of-Data-Possession](https://hackmd.io/2uRBltuIT7yX0CyczJevYg?view)
4. [Codex market implementation](https://github.com/codex-storage/nim-codex/blob/master/codex/market.nim)
5. [CODEX/NODE-DISPERSAL](https://github.com/vacp2p/rfc-index/blob/codex-disperal/codex/slot-dispersal.md)

